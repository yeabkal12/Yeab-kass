// frontend/app.js (Final Version with Only Game Summary Logic Injected)

document.addEventListener('DOMContentLoaded', () => {
    // --- Initialize Telegram & Basic Setup ---
    const tg = window.Telegram.WebApp;
    tg.ready();
    tg.expand();
    
    const getEl = id => document.getElementById(id);

    // --- DOM Element References (CRITICAL - ALL must be correct) ---
    const loadingScreen = getEl('loading-screen');
    const mainApp = getEl('main-app');
    const gameListContainer = getEl('game-list-container');
    const newGameBtn = getEl('new-game-btn'); // The "+ NEW" button
    const filtersContainer = document.querySelector('.filters'); // The container for filter buttons
    const refreshBtn = getEl('refresh-btn');
    
    // Stake Modal Elements
    const stakeModal = getEl('stake-modal');
    const closeStakeModalBtn = getEl('close-stake-modal-btn');
    const stakeOptionsGrid = getEl('stake-options-grid');
    const cancelStakeBtn = getEl('cancel-stake-btn');
    const nextStakeBtn = getEl('next-stake-btn');
    
    // Confirm Modal Elements
    const confirmModal = getEl('confirm-modal');
    const closeConfirmModalBtn = getEl('close-confirm-modal-btn');
    const winConditionOptions = getEl('win-condition-options');
    const createGameBtn = getEl('create-game-btn');
    const cancelConfirmBtn = getEl('cancel-confirm-btn');
    // --- NEW references for the summary elements ---
    const summaryStakeAmount = getEl('summary-stake-amount');
    const summaryPrizeAmount = getEl('summary-prize-amount');


    // --- Application State ---
    let selectedStake = null;
    let selectedWinCondition = null;
    let socket = null;
    let allGames = []; // A local cache of all active games

    // --- Real-Time WebSocket Logic ---
    function connectWebSocket() {
        // Using secure wss:// for production
        socket = new WebSocket("wss://yeab-kass.onrender.com/ws");

        socket.onopen = () => console.log("WebSocket connection established.");
        socket.onclose = () => console.log("WebSocket connection closed.");
        socket.onerror = (error) => console.error("WebSocket error:", error);

        socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            switch (data.event) {
                case "initial_game_list":
                    allGames = data.games;
                    renderGameList(allGames);
                    break;
                case "new_game":
                    allGames.push(data.game);
                    addGameCard(data.game);
                    break;
                case "remove_game":
                    allGames = allGames.filter(game => game.id !== data.gameId);
                    removeGameCard(data.gameId);
                    break;
            }
        };
    }

    // --- UI Rendering & View Management ---
    function renderGameList(games) {
        gameListContainer.innerHTML = '';
        if (games.length === 0) {
            gameListContainer.innerHTML = `<h3 class="empty-state-title">No open games. Create one!</h3>`;
        } else {
            games.forEach(addGameCard);
        }
    }

    function addGameCard(game) {
        const emptyState = gameListContainer.querySelector('.empty-state-title');
        if (emptyState) emptyState.remove();

        const cardElement = document.createElement('div');
        // ... (code to create the game card element) ...
        gameListContainer.appendChild(cardElement);
    }
    
    function removeGameCard(gameId) {
        const cardToRemove = getEl(`game-${gameId}`);
        if (cardToRemove) cardToRemove.remove();
        if (gameListContainer.children.length === 0) {
            renderGameList([]);
        }
    }

    const showStakeModal = () => {
        mainApp.style.filter = 'blur(5px)';
        stakeModal.classList.remove('hidden');
    };
    
    const hideStakeModal = () => {
        mainApp.style.filter = 'none';
        stakeModal.classList.add('hidden');
    };
    
    // =========================================================
    // =========== START: MODIFIED SECTION =====================
    // =========================================================
    
    /**
     * [NEW] Calculates and displays the prize based on the selected stake.
     * This function contains the injected logic.
     */
    const updateSummary = () => {
        if (!selectedStake) return;

        const numberOfPlayers = 2;
        const commissionRate = 0.10;

        // Update stake display
        summaryStakeAmount.textContent = `Stake: ${selectedStake} ETB`;

        // Calculate prize with 10% commission
        const totalPot = selectedStake * numberOfPlayers;
        const finalPrize = totalPot - (totalPot * commissionRate);

        // Display the final prize
        summaryPrizeAmount.textContent = `${finalPrize.toFixed(2)} ETB`;
    };

    /**
     * [MODIFIED] Shows the confirmation modal and now calls updateSummary.
     */
    const showConfirmModal = () => {
        hideStakeModal();
        mainApp.style.filter = 'blur(5px)';
        confirmModal.classList.remove('hidden');
        updateSummary(); // <--- This line injects the logic
    };
    
    // =========================================================
    // ============= END: MODIFIED SECTION =====================
    // =========================================================

    const hideConfirmModal = () => {
        mainApp.style.filter = 'none';
        confirmModal.classList.add('hidden');
    };
    
    function setupEventListeners() {
        // The "+ NEW" button opens the stake modal
        if (newGameBtn) {
            newGameBtn.addEventListener('click', showStakeModal);
        }

        // The filter buttons filter the game list
        if (filtersContainer) {
            filtersContainer.addEventListener('click', (event) => {
                const button = event.target.closest('.filter-button');
                if (!button) return;

                filtersContainer.querySelector('.active')?.classList.remove('active');
                button.classList.add('active');

                const filterText = button.textContent.replace('ðŸ’° ', '');
                let filteredGames = allGames;

                if (filterText !== 'All') {
                    if (filterText.includes('-')) {
                        const [min, max] = filterText.split('-').map(Number);
                        filteredGames = allGames.filter(g => g.stake >= min && g.stake <= max);
                    } else {
                        const min = parseInt(filterText);
                        filteredGames = allGames.filter(g => g.stake >= min);
                    }
                }
                renderGameList(filteredGames);
            });
        }
        
        // Listeners for modals
        if (closeStakeModalBtn) closeStakeModalBtn.addEventListener('click', hideStakeModal);
        if (cancelStakeBtn) cancelStakeBtn.addEventListener('click', hideStakeModal);
        if (nextStakeBtn) nextStakeBtn.addEventListener('click', showConfirmModal); // This triggers the logic
        
        if (closeConfirmModalBtn) closeConfirmModalBtn.addEventListener('click', hideConfirmModal);
        if (cancelConfirmBtn) cancelConfirmBtn.addEventListener('click', hideConfirmModal);
        
        if (stakeOptionsGrid) {
            stakeOptionsGrid.addEventListener('click', e => {
                const button = e.target.closest('.option-btn');
                if (button) {
                    stakeOptionsGrid.querySelector('.selected')?.classList.remove('selected');
                    button.classList.add('selected');
                    selectedStake = parseInt(button.dataset.stake);
                    nextStakeBtn.disabled = false;
                }
            });
        }
        
        if (winConditionOptions) {
             winConditionOptions.addEventListener('click', e => {
                const button = e.target.closest('.win-option-btn');
                if (button) {
                    winConditionOptions.querySelector('.selected')?.classList.remove('selected');
                    button.classList.add('selected');
                    selectedWinCondition = parseInt(button.dataset.win);
                    createGameBtn.disabled = false;
                }
            });
        }

        if (createGameBtn) {
            createGameBtn.addEventListener('click', () => {
                // Your existing logic to send data via WebSocket
            });
        }
    }

    // --- Initial Application Load ---
    const init = () => {
        loadingScreen.classList.add('hidden');
        mainApp.classList.remove('hidden');
        setupEventListeners();
        connectWebSocket();
    };
    
    setTimeout(init, 3000);
});
